Висновок
У ході дослідження було порівняно три алгоритми сортування — сортування вставками, сортування злиттям та вбудований у Python алгоритм Timsort — за допомогою емпіричного тестування на масивах різних розмірів. Для точного заміру часу виконання використовувався модуль timeit.

Результати показали таке:

Insertion Sort (вставками) працює швидко лише на дуже малих масивах (до 500–1000 елементів), але демонструє експоненціальне зростання часу при збільшенні розміру вхідних даних. Це підтверджує його теоретичну складність — O(n²).

Merge Sort (злиттям) стабільно показує час виконання, який відповідає складності O(n log n). Він ефективний на великих об'ємах, але трохи поступається Timsort через відсутність адаптивності.

Timsort (вбудована функція sorted) був найшвидшим серед усіх протестованих алгоритмів. Його продуктивність пояснюється гібридною природою: він поєднує переваги сортування вставками на малих ділянках масиву (де це вигідно), та сортування злиттям — на великих. Завдяки цьому він ефективно обробляє як частково впорядковані, так і довільні дані.

Таким чином, Timsort перевершує класичні алгоритми у більшості практичних випадків, що й пояснює його використання у вбудованих функціях Python (sorted() і .sort()). Це демонструє, чому програмісти зазвичай обирають стандартні бібліотечні інструменти замість написання власних реалізацій алгоритмів сортування.
